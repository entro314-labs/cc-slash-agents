import { describe, it, expect, beforeEach, vi } from 'vitest'
import { vol } from 'memfs'
import { CommandGenerator } from '../../../src/core/command-generator.js'
import { sampleFileStructure, sampleAgentFiles } from '../../fixtures/sample-agents.js'
import type { AgentFile } from '../../../src/types.js'

describe('CommandGenerator', () => {
  beforeEach(() => {
    vol.reset()
    vol.fromJSON(sampleFileStructure)
  })

  describe('generateCommandName', () => {
    it('should generate clean command names', () => {
      expect(CommandGenerator.generateCommandName('cli-integrity-analyzer')).toBe('analyze-integrity')
      expect(CommandGenerator.generateCommandName('senior-code-reviewer')).toBe('review-code')
      expect(CommandGenerator.generateCommandName('mindful-dev')).toBe('mindful-dev')
      expect(CommandGenerator.generateCommandName('docs-architect')).toBe('create-docs')
    })

    it('should handle special mappings', () => {
      expect(CommandGenerator.generateCommandName('codebase-optimizer')).toBe('optimize-codebase')
      expect(CommandGenerator.generateCommandName('supabase-to-clerk-complete-migrator')).toBe('migrate-auth')
    })

    it('should remove common suffixes', () => {
      expect(CommandGenerator.generateCommandName('test-agent')).toBe('test')
      expect(CommandGenerator.generateCommandName('security-specialist')).toBe('security')
      expect(CommandGenerator.generateCommandName('api-expert')).toBe('api')
    })

    it('should remove common prefixes', () => {
      expect(CommandGenerator.generateCommandName('ai-helper')).toBe('helper')
      expect(CommandGenerator.generateCommandName('auto-generator')).toBe('auto')
    })

    it('should handle verb-noun patterns', () => {
      expect(CommandGenerator.generateCommandName('code-reviewer')).toBe('reviewer-code')
    })

    it('should handle simple names without transformation', () => {
      expect(CommandGenerator.generateCommandName('simple')).toBe('simple')
      expect(CommandGenerator.generateCommandName('helper')).toBe('helper')
    })
  })

  describe('generateCommandContent', () => {
    const createMockAgent = (overrides: Partial<AgentFile> = {}): AgentFile => ({
      path: '/test-project/.claude/agents/test-agent.md',
      relativePath: 'test-agent.md',
      frontmatter: {
        name: 'test-agent',
        description: 'Test agent for unit testing',
        tools: ['Read', 'Write', 'Edit'],
        model: 'sonnet',
      },
      content: 'Test agent content',
      scope: 'project',
      ...overrides,
    })

    it('should generate correct command content structure', () => {
      const agent = createMockAgent()
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).toContain('<!-- ccsa:generated -->')
      expect(content).toContain('<!-- Generated by cc-slash-agents v1.0.0 -->')
      expect(content).toContain('<!-- Source: test-agent.md -->')
      expect(content).toContain('<!-- Agent: test-agent -->')
      expect(content).toContain('<!-- Scope: project -->')
    })

    it('should include proper frontmatter', () => {
      const agent = createMockAgent()
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).toContain('description: Test - test agent for unit testing')
      expect(content).toContain('argument-hint: "focus areas, file patterns, or specific requirements"')
      expect(content).toContain('allowed-tools: [Read, Write, Edit]')
      expect(content).toContain('model: sonnet')
    })

    it('should handle tools as string', () => {
      const agent = createMockAgent({
        frontmatter: {
          name: 'test-agent',
          description: 'Test agent',
          tools: 'Read, Write, Edit',
        },
      })
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).toContain('allowed-tools: [Read, Write, Edit]')
    })

    it('should handle missing tools', () => {
      const agent = createMockAgent({
        frontmatter: {
          name: 'test-agent',
          description: 'Test agent',
        },
      })
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).not.toContain('allowed-tools:')
    })

    it('should handle missing model', () => {
      const agent = createMockAgent({
        frontmatter: {
          name: 'test-agent',
          description: 'Test agent',
          tools: ['Read'],
        },
      })
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).not.toContain('model:')
    })

    it('should generate proper usage instructions', () => {
      const agent = createMockAgent()
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).toContain('Use the test-agent agent to')
      expect(content).toContain('Arguments: $ARGUMENTS')
      expect(content).toContain('*Generated by [cc-slash-agents]')
    })

    it('should include timestamp in generated content', () => {
      const agent = createMockAgent()
      const content = CommandGenerator.generateCommandContent(agent)

      expect(content).toMatch(/<!-- Generated: \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z -->/)
    })
  })

  describe('generateCommand', () => {
    const createMockAgent = (name = 'test-agent'): AgentFile => ({
      path: `/test-project/.claude/agents/${name}.md`,
      relativePath: `${name}.md`,
      frontmatter: {
        name,
        description: `${name} description`,
        tools: ['Read', 'Write'],
      },
      content: 'Content',
      scope: 'project',
    })

    it('should generate command file successfully', async () => {
      const agent = createMockAgent()

      const result = await CommandGenerator.generateCommand(agent, 'project', false)

      expect(result.agentFile).toBe(agent)
      expect(result.commandName).toBe('test')
      expect(result.commandPath).toBe('/test-project/.claude/commands/test.md')
      expect(result.content).toContain('test-agent')

      // Verify file was written
      const fileContent = vol.readFileSync('/test-project/.claude/commands/test.md', 'utf-8')
      expect(fileContent).toContain('<!-- ccsa:generated -->')
    })

    it('should create directories if they do not exist', async () => {
      vol.reset() // Start with empty filesystem
      const agent = createMockAgent()

      await CommandGenerator.generateCommand(agent, 'project', false)

      // Should have created the directory structure
      expect(vol.existsSync('/test-project/.claude/commands')).toBe(true)
      expect(vol.existsSync('/test-project/.claude/commands/test.md')).toBe(true)
    })

    it('should throw error if file exists and is not generated without force', async () => {
      // Create a manual command file
      vol.fromJSON({
        '/test-project/.claude/commands/test.md': 'Manually created command',
      })

      const agent = createMockAgent()

      await expect(CommandGenerator.generateCommand(agent, 'project', false)).rejects.toThrow(
        'already exists and was not generated by ccsa'
      )
    })

    it('should overwrite file when force is true', async () => {
      vol.fromJSON({
        '/test-project/.claude/commands/test.md': 'Old content',
      })

      const agent = createMockAgent()
      await CommandGenerator.generateCommand(agent, 'project', true)

      const content = vol.readFileSync('/test-project/.claude/commands/test.md', 'utf-8')
      expect(content).toContain('<!-- ccsa:generated -->')
      expect(content).not.toContain('Old content')
    })

    it('should handle user scope commands', async () => {
      const agent = createMockAgent()
      agent.scope = 'user'

      const result = await CommandGenerator.generateCommand(agent, 'user', false)

      expect(result.commandPath).toMatch(/\.claude\/commands\/test\.md$/)
    })
  })

  describe('resolveNamingConflicts', () => {
    it('should handle no conflicts', () => {
      const agents = [
        { frontmatter: { name: 'unique-agent-1' } },
        { frontmatter: { name: 'unique-agent-2' } },
      ] as AgentFile[]

      const nameMap = CommandGenerator.resolveNamingConflicts(agents)

      expect(nameMap.get('unique-agent-1')).toBe('unique-agent-1')
      expect(nameMap.get('unique-agent-2')).toBe('unique-agent-2')
    })

    it('should resolve naming conflicts with suffixes', () => {
      const agents = [
        { frontmatter: { name: 'code-reviewer' }, scope: 'project' },
        { frontmatter: { name: 'senior-code-reviewer' }, scope: 'user' },
      ] as AgentFile[]

      const nameMap = CommandGenerator.resolveNamingConflicts(agents)

      expect(nameMap.get('code-reviewer')).toBe('reviewer-code')
      expect(nameMap.get('senior-code-reviewer')).toBe('review-code')
    })

    it('should handle user scope conflicts', () => {
      const agents = [
        { frontmatter: { name: 'test-agent' }, scope: 'project' },
        { frontmatter: { name: 'test-agent' }, scope: 'user' },
      ] as AgentFile[]

      const nameMap = CommandGenerator.resolveNamingConflicts(agents)
      const names = Array.from(nameMap.values())

      // Should have different names
      expect(names[0]).not.toBe(names[1])
      expect(names).toContain('test-user')
    })

    it('should handle multiple conflicts with numeric suffixes', () => {
      const agents = [
        { frontmatter: { name: 'test-agent-1' } },
        { frontmatter: { name: 'test-agent-2' } },
        { frontmatter: { name: 'test-agent-3' } },
      ] as AgentFile[]

      const nameMap = CommandGenerator.resolveNamingConflicts(agents)
      const names = Array.from(nameMap.values())

      // All names should be unique
      expect(new Set(names).size).toBe(names.length)
    })
  })

  describe('edge cases', () => {
    it('should handle empty agent name', () => {
      expect(() => CommandGenerator.generateCommandName('')).not.toThrow()
    })

    it('should handle agent names with special characters', () => {
      const result = CommandGenerator.generateCommandName('test@agent#with$special%chars')
      expect(result).toBeTruthy()
      expect(typeof result).toBe('string')
    })

    it('should handle very long agent names', () => {
      const longName = 'a'.repeat(200)
      const result = CommandGenerator.generateCommandName(longName)
      expect(result).toBeTruthy()
    })
  })
})
