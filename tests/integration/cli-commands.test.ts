import { describe, it, expect, beforeEach, vi } from 'vitest'
import { vol } from 'memfs'
import { sampleFileStructure } from '../fixtures/sample-agents.js'

// Import command functions directly for testing
import { FileDiscovery } from '../../src/core/file-discovery.js'
import { CommandGenerator } from '../../src/core/command-generator.js'
import { initializeStructure } from '../../src/commands/init.js'
import { cleanCommands } from '../../src/commands/clean.js'

describe('CLI Commands Integration', () => {
  beforeEach(() => {
    vol.reset()
    vol.fromJSON(sampleFileStructure)
  })

  describe('generate command flow', () => {
    it('should complete full generation flow', async () => {
      // Discover agents
      const agents = await FileDiscovery.discoverAgents('project')
      expect(agents).toHaveLength(2) // project-agent + code-reviewer

      // Resolve naming conflicts (returns map of all agents with their final names)
      const nameMap = CommandGenerator.resolveNamingConflicts(agents)
      expect(nameMap.size).toBe(2) // All agents get mapped

      // Generate commands
      for (const agent of agents) {
        const result = await CommandGenerator.generateCommand(agent, 'project', false)
        expect(result.commandName).toBeTruthy()
        expect(result.commandPath).toBeTruthy()
        expect(result.content).toContain('<!-- ccsa:generated -->')
      }

      // Verify commands were created
      const commands = await FileDiscovery.discoverCommands('project')
      const generatedCommands = commands.filter((c) => FileDiscovery.isGeneratedFile(c.path))
      expect(generatedCommands).toHaveLength(3) // 1 from sample structure + 2 newly generated
    })

    it('should handle scope filtering correctly', async () => {
      const projectAgents = await FileDiscovery.discoverAgents('project')
      const userAgents = await FileDiscovery.discoverAgents('user')
      const allAgents = await FileDiscovery.discoverAgents('both')

      expect(projectAgents).toHaveLength(2)
      expect(userAgents).toHaveLength(2)
      expect(allAgents).toHaveLength(4)
      expect(allAgents.length).toBe(projectAgents.length + userAgents.length)
    })

    it('should prevent overwriting non-generated files', async () => {
      const agent = (await FileDiscovery.discoverAgents('project'))[0]

      // Create a manual command with the same name
      const commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)
      vol.writeFileSync(`/test-project/.claude/commands/${commandName}.md`, 'Manual command content')

      // Should throw error when trying to generate without force
      await expect(CommandGenerator.generateCommand(agent, 'project', false)).rejects.toThrow(
        'already exists and was not generated by ccsa'
      )

      // Should succeed with force
      await expect(CommandGenerator.generateCommand(agent, 'project', true)).resolves.toBeDefined()
    })
  })

  describe('sync command flow', () => {
    it('should identify commands needing sync', async () => {
      // Generate initial commands
      const agents = await FileDiscovery.discoverAgents('project')
      for (const agent of agents) {
        await CommandGenerator.generateCommand(agent, 'project', false)
      }

      // Get commands before sync
      const commandsBefore = await FileDiscovery.discoverCommands('project')
      const generatedBefore = commandsBefore.filter((c) => FileDiscovery.isGeneratedFile(c.path))

      // Simulate agent update by regenerating
      for (const agent of agents) {
        await CommandGenerator.generateCommand(agent, 'project', true)
      }

      // Verify commands still exist
      const commandsAfter = await FileDiscovery.discoverCommands('project')
      const generatedAfter = commandsAfter.filter((c) => FileDiscovery.isGeneratedFile(c.path))

      expect(generatedAfter).toHaveLength(generatedBefore.length)
    })

    it('should handle orphaned commands', async () => {
      // Create a generated command that no longer has a corresponding agent
      vol.writeFileSync(
        '/test-project/.claude/commands/orphaned.md',
        '<!-- ccsa:generated -->\nOrphaned generated command'
      )

      const commands = await FileDiscovery.discoverCommands('project')
      const orphanedCommand = commands.find((c) => c.relativePath === 'orphaned.md')

      expect(orphanedCommand).toBeDefined()
      expect(FileDiscovery.isGeneratedFile(orphanedCommand!.path)).toBe(true)
    })
  })

  describe('init command flow', () => {
    it('should initialize project structure', async () => {
      vol.reset() // Start with empty filesystem

      await initializeStructure({ global: false })

      // Check that directories were created
      expect(vol.existsSync('/test-project/.claude')).toBe(true)
      expect(vol.existsSync('/test-project/.claude/agents')).toBe(true)
      expect(vol.existsSync('/test-project/.claude/commands')).toBe(true)

      // Check that example files were created
      expect(vol.existsSync('/test-project/.claude/agents/example-agent.md')).toBe(true)
      expect(vol.existsSync('/test-project/.claude/README.md')).toBe(true)

      // Verify example agent is valid
      const agents = await FileDiscovery.discoverAgents('project')
      expect(agents).toHaveLength(1) // Only example-agent should be created
      expect(agents[0].frontmatter.name).toBe('example-agent')
    })

    it('should initialize user structure', async () => {
      vol.reset()

      await initializeStructure({ global: true })

      // Check that user directories were created
      expect(vol.readdirSync('/Users/testuser/.claude')).toBeDefined()

      // Should contain agents and commands directories
      const userAgents = await FileDiscovery.discoverAgents('user')
      expect(userAgents).toHaveLength(1)
      expect(userAgents[0].frontmatter.name).toBe('productivity-helper')
    })

    it('should not overwrite existing files', async () => {
      // Create existing example agent
      vol.fromJSON({
        '/test-project/.claude/agents/example-agent.md': 'Existing content',
      })

      await initializeStructure({ global: false })

      // Should not have overwritten existing file
      const content = vol.readFileSync('/test-project/.claude/agents/example-agent.md', 'utf-8')
      expect(content).toBe('Existing content')
    })
  })

  describe('clean command flow', () => {
    it('should clean only generated commands', async () => {
      // Create both generated and manual commands
      const generatedContent = '<!-- ccsa:generated -->\nGenerated command'
      const manualContent = 'Manual command content'

      vol.fromJSON({
        '/test-project/.claude/commands/generated.md': generatedContent,
        '/test-project/.claude/commands/manual.md': manualContent,
      })

      // Mock the confirmation to always return true
      vi.stubGlobal('process', {
        ...process,
        stdin: {
          on: vi.fn(),
          off: vi.fn(),
          pause: vi.fn(),
          resume: vi.fn(),
        },
        stdout: {
          write: vi.fn(),
        },
      })

      await cleanCommands({ scope: 'project', yes: true })

      // Generated command should be deleted
      expect(vol.existsSync('/test-project/.claude/commands/generated.md')).toBe(false)

      // Manual command should remain
      expect(vol.existsSync('/test-project/.claude/commands/manual.md')).toBe(true)
    })

    it('should handle clean with no generated commands', async () => {
      vol.fromJSON({
        '/test-project/.claude/commands/manual-only.md': 'Manual command',
      })

      // Should not throw
      await expect(cleanCommands({ scope: 'project', yes: true })).resolves.not.toThrow()
    })
  })

  describe('list command flow', () => {
    it('should categorize agents and commands correctly', async () => {
      const agents = await FileDiscovery.discoverAgents('both')
      const commands = await FileDiscovery.discoverCommands('both')

      // Categorize agents by scope
      const projectAgents = agents.filter((a) => a.scope === 'project')
      const userAgents = agents.filter((a) => a.scope === 'user')

      expect(projectAgents).toHaveLength(2)
      expect(userAgents).toHaveLength(2)

      // Categorize commands by type
      const generatedCommands = commands.filter((c) => FileDiscovery.isGeneratedFile(c.path))
      const manualCommands = commands.filter((c) => !FileDiscovery.isGeneratedFile(c.path))

      expect(generatedCommands).toHaveLength(1) // Only the one from sample file structure
      expect(manualCommands).toHaveLength(2)
    })

    it('should suggest commands for agents without generated commands', async () => {
      const agents = await FileDiscovery.discoverAgents('both')
      const commands = await FileDiscovery.discoverCommands('both')

      const generatedCommandNames = commands
        .filter((c) => FileDiscovery.isGeneratedFile(c.path))
        .map((c) => c.relativePath.replace('.md', ''))

      const agentsWithoutCommands = agents.filter((agent) => {
        const commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)
        return !generatedCommandNames.includes(commandName)
      })

      // Should have agents without generated commands
      expect(agentsWithoutCommands.length).toBeGreaterThan(0)
    })
  })

  describe('end-to-end workflow', () => {
    it('should support complete development workflow', async () => {
      vol.reset()

      // 1. Initialize project
      await initializeStructure({ global: false })

      // 2. Verify agents were created
      const agents = await FileDiscovery.discoverAgents('project')
      expect(agents).toHaveLength(1)

      // 3. Generate commands
      for (const agent of agents) {
        await CommandGenerator.generateCommand(agent, 'project', false)
      }

      // 4. Verify commands were created
      const commands = await FileDiscovery.discoverCommands('project')
      const generatedCommands = commands.filter((c) => FileDiscovery.isGeneratedFile(c.path))
      expect(generatedCommands).toHaveLength(1)

      // 5. Sync (update) commands
      for (const agent of agents) {
        await CommandGenerator.generateCommand(agent, 'project', true)
      }

      // 6. Verify commands still exist after sync
      const commandsAfterSync = await FileDiscovery.discoverCommands('project')
      const generatedAfterSync = commandsAfterSync.filter((c) => FileDiscovery.isGeneratedFile(c.path))
      expect(generatedAfterSync).toHaveLength(1)

      // 7. Clean generated commands
      await cleanCommands({ scope: 'project', yes: true })

      // 8. Verify generated commands were removed
      const finalCommands = await FileDiscovery.discoverCommands('project')
      const finalGenerated = finalCommands.filter((c) => FileDiscovery.isGeneratedFile(c.path))
      expect(finalGenerated).toHaveLength(0)
    })
  })
})
