import { writeFileSync, mkdirSync, existsSync } from 'fs'
import { join, dirname, basename } from 'path'
import type { AgentFile, GeneratedCommand } from '../types.js'
import { PathUtils } from '../utils/paths.js'
import { Logger } from '../utils/logger.js'
import { FileDiscovery } from './file-discovery.js'

export class CommandGenerator {
  /**
   * Generate command name from agent name
   */
  static generateCommandName(agentName: string): string {
    // Remove common suffixes and prefixes for cleaner command names
    const cleanName = agentName
      .replace(/(-agent|-specialist|-expert|-analyzer|-auditor|-engineer|-architect|-optimizer|-generator)$/, '')
      .replace(/^(the-|ai-|auto-)/, '')

    // Special mappings for better UX
    const nameMap: Record<string, string> = {
      'cli-integrity-analyzer': 'analyze-integrity',
      'senior-code-reviewer': 'review-code',
      'mindful-dev': 'mindful-dev',
      'docs-architect': 'create-docs',
      'codebase-optimizer': 'optimize-codebase',
      'supabase-to-clerk-complete-migrator': 'migrate-auth',
      'code-documentation-auditor': 'audit-docs',
      'comprehensive-test-engineer': 'test-comprehensive',
    }

    if (nameMap[agentName]) {
      return nameMap[agentName]
    }

    // Convert kebab-case to more intuitive command names
    if (cleanName.includes('-')) {
      const parts = cleanName.split('-')

      // Handle common patterns
      if (parts[0] === 'code' && parts.length === 2) {
        return `${parts[1]}-code` // code-reviewer -> review-code
      }

      if (parts[parts.length - 1] === 'dev' || parts[parts.length - 1] === 'developer') {
        return parts.slice(0, -1).join('-')
      }

      // For compound names, create verb-noun pattern when possible
      const actionWords = [
        'analyze',
        'review',
        'test',
        'audit',
        'migrate',
        'optimize',
        'create',
        'generate',
        'validate',
      ]
      const hasAction = parts.some((part) => actionWords.includes(part))

      if (!hasAction && parts.length === 2) {
        // Try to infer action from context
        if (parts[1].includes('review') || parts[0] === 'senior') return `review-${parts[0]}`
        if (parts[1].includes('test') || parts[1].includes('testing')) return `test-${parts[0]}`
        if (parts[1].includes('doc') || parts[1].includes('documentation')) return `docs-${parts[0]}`
      }
    }

    return cleanName
  }

  /**
   * Generate the content for a command wrapper
   */
  static generateCommandContent(agent: AgentFile): string {
    const timestamp = new Date().toISOString()
    const commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)

    // Extract key features from description for better command hints
    const description = agent.frontmatter.description
    const hasProactive = description.includes('PROACTIVELY') || description.includes('MUST BE USED')

    const frontmatter: string[] = [
      '---',
      `description: ${CommandGenerator.generateCommandDescription(agent)}`,
      `argument-hint: "focus areas, file patterns, or specific requirements"`,
    ]

    // Include tools if specified in agent
    if (agent.frontmatter.tools) {
      const tools = Array.isArray(agent.frontmatter.tools)
        ? agent.frontmatter.tools
        : (agent.frontmatter.tools as string).split(',').map((t: string) => t.trim())

      if (tools.length > 0) {
        frontmatter.push(`allowed-tools: [${tools.join(', ')}]`)
      }
    }

    // Include model preference if specified
    if (agent.frontmatter.model) {
      frontmatter.push(`model: ${agent.frontmatter.model}`)
    }

    frontmatter.push('---')

    const content = [
      '<!-- ccsa:generated -->',
      `<!-- Generated by cc-slash-agents v1.0.0 -->`,
      `<!-- Source: ${agent.relativePath} -->`,
      `<!-- Agent: ${agent.frontmatter.name} -->`,
      `<!-- Scope: ${agent.scope} -->`,
      `<!-- Generated: ${timestamp} -->`,
      '',
      ...frontmatter,
      '',
      `Use the ${agent.frontmatter.name} agent to ${CommandGenerator.extractAgentPurpose(agent)}.`,
      '',
      CommandGenerator.generateUsageInstructions(agent),
      '',
      'Arguments: $ARGUMENTS',
      '',
      '---',
      '',
      `*Generated by [cc-slash-agents](https://npmjs.com/package/cc-slash-agents). Run \`ccsa sync\` to update.*`,
    ]

    return content.join('\n')
  }

  /**
   * Extract the main purpose from agent description
   */
  private static extractAgentPurpose(agent: AgentFile): string {
    const description = agent.frontmatter.description.toLowerCase()

    // Remove "must be used" and "proactively" noise
    const cleaned = description
      .replace(/must be used for/i, '')
      .replace(/use proactively/i, '')
      .replace(/proactively/i, '')
      .replace(/when/i, '')
      .trim()

    // Extract first sentence or meaningful clause
    const firstSentence = cleaned.split('.')[0]
    if (firstSentence.length < 100) {
      return firstSentence
    }

    // If too long, extract key phrase
    return cleaned.substring(0, 80).trim() + '...'
  }

  /**
   * Generate command description from agent info
   */
  private static generateCommandDescription(agent: AgentFile): string {
    const purpose = CommandGenerator.extractAgentPurpose(agent)
    const commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)

    return `${commandName.charAt(0).toUpperCase() + commandName.slice(1)} - ${purpose}`
  }

  /**
   * Generate usage instructions based on agent capabilities
   */
  private static generateUsageInstructions(agent: AgentFile): string {
    const description = agent.frontmatter.description
    const name = agent.frontmatter.name

    // Provide context-specific usage hints
    if (name.includes('review')) {
      return 'Provide file paths, code snippets, or specific areas to review for comprehensive analysis.'
    }

    if (name.includes('test')) {
      return 'Specify test types, file patterns, or coverage requirements for testing strategy.'
    }

    if (name.includes('migrate')) {
      return 'Specify migration source, target, and any special requirements or constraints.'
    }

    if (name.includes('analyze') || name.includes('audit')) {
      return 'Specify focus areas, file patterns, or specific analysis criteria for targeted assessment.'
    }

    if (name.includes('docs') || name.includes('documentation')) {
      return 'Specify documentation type, target audience, or specific sections to generate.'
    }

    if (description.includes('educational') || name.includes('mindful')) {
      return 'Describe the feature or concept you want to implement with step-by-step explanations.'
    }

    return 'Provide specific requirements, focus areas, or context for the agent to work with.'
  }

  /**
   * Generate command file and return metadata
   */
  static async generateCommand(
    agent: AgentFile,
    targetScope: 'project' | 'user' = 'project',
    force = false
  ): Promise<GeneratedCommand> {
    const commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)

    const commandsDir = targetScope === 'project' ? PathUtils.getProjectCommandsDir() : PathUtils.getUserCommandsDir()

    const commandPath = join(commandsDir, `${commandName}.md`)
    const content = CommandGenerator.generateCommandContent(agent)

    // Check if file exists and handle conflicts
    if (existsSync(commandPath) && !force) {
      // Check if it's our generated file
      if (!FileDiscovery.isGeneratedFile(commandPath)) {
        throw new Error(
          `Command file ${commandName}.md already exists and was not generated by ccsa. Use --force to overwrite.`
        )
      }
    }

    // Ensure directory exists
    mkdirSync(dirname(commandPath), { recursive: true })

    // Write the file
    writeFileSync(commandPath, content, 'utf-8')

    Logger.debug(`Generated command: ${commandPath}`)

    return {
      agentFile: agent,
      commandName,
      commandPath,
      content,
    }
  }

  /**
   * Handle naming conflicts by generating alternative names
   */
  static resolveNamingConflicts(agents: AgentFile[]): Map<string, string> {
    const nameMap = new Map<string, string>()
    const usedNames = new Set<string>()

    for (const agent of agents) {
      let commandName = CommandGenerator.generateCommandName(agent.frontmatter.name)
      let originalName = commandName
      let suffix = 1

      // Handle conflicts by adding suffixes
      while (usedNames.has(commandName)) {
        // Try contextual suffixes first
        if (suffix === 1) {
          if (agent.scope === 'user') {
            commandName = `${originalName}-user`
          } else if (agent.frontmatter.name.includes('senior')) {
            commandName = `${originalName}-senior`
          } else if (agent.frontmatter.name.includes('comprehensive')) {
            commandName = `${originalName}-full`
          } else {
            commandName = `${originalName}-${suffix}`
          }
        } else {
          commandName = `${originalName}-${suffix}`
        }
        suffix++
      }

      nameMap.set(agent.frontmatter.name, commandName)
      usedNames.add(commandName)
    }

    return nameMap
  }
}
